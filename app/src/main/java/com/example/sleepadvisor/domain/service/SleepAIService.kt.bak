package com.example.sleepadvisor.domain.service

import com.example.sleepadvisor.domain.model.SleepSession
import com.example.sleepadvisor.domain.model.SleepStage
import com.example.sleepadvisor.domain.model.SleepStageType
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.time.Duration
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Serviço que utiliza IA avançada para gerar análises detalhadas e dicas personalizadas de sono
 * Integra dados do Health Connect e utiliza algoritmos de simulação para estágios do sono
 */
@Singleton
class SleepAIService @Inject constructor(
    private val okHttpClient: OkHttpClient,
    private val gson: Gson
) {
    private val dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    private val timeFormatter = DateTimeFormatter.ofPattern("HH:mm")
    
    /**
     * Gera dicas personalizadas e análises detalhadas baseadas nos dados de sono da última semana
     * Inclui análises individualizadas por noite, simulação de ciclos de sono, e métricas de saúde
     */
    suspend fun generateSleepAdvice(weekSessions: List<SleepSession>): SleepAdvice = withContext(Dispatchers.IO) {
        try {
            if (weekSessions.isEmpty()) {
                return@withContext SleepAdvice(
                    tips = listOf("Registre seu sono por alguns dias para receber dicas personalizadas."),
                    warnings = emptyList(),
                    positiveReinforcement = null,
                    dailyAnalysis = emptyList(),
                    scientificFact = "Sabia que o sono é dividido em 4-6 ciclos de 90 minutos cada? Cada ciclo passa por estágios leve, profundo e REM."
                )
            }
            
            // Preparar dados para análise geral com métricas avançadas
            val sleepData = weekSessions.map { session ->
                // Extrair dados de frequência cardíaca e outros dados de saúde (simulados por enquanto)
                // Em uma implementação real, esses dados viriam do Health Connect
                val heartRateData = simulateHeartRateData(session)
                val oxygenData = simulateOxygenData(session)
                val snoringData = simulateSnoringData(session)
                val movementData = simulateMovementData(session)
                
                SleepDataDto(
                    date = session.startTime.format(dateFormatter),
                    totalSleep = "${session.duration.toHours()}h${session.duration.toMinutesPart()}min",
                    deepSleepPercentage = session.deepSleepPercentage,
                    remSleepPercentage = session.remSleepPercentage,
                    lightSleepPercentage = session.lightSleepPercentage,
                    wakeCount = session.wakeDuringNightCount,
                    efficiency = session.efficiency,
                    heartRateAvg = heartRateData.average,
                    heartRateMin = heartRateData.min,
                    heartRateMax = heartRateData.max,
                    oxygenSaturation = oxygenData,
                    snoring = snoringData.detected,
                    snoringDuration = snoringData.duration,
                    movementCount = movementData,
                    bedtime = session.startTime.format(timeFormatter),
                    wakeupTime = session.endTime.format(timeFormatter),
                    isDataEstimated = session.stages.isEmpty()
                )
            }
            
            // Verificar se há sonecas registradas
            val naps = detectNaps(weekSessions)
            
            // Gerar análise detalhada para cada noite com ciclos de sono simulados
            val dailyAnalyses = weekSessions.map { session ->
                // Extrair dados de saúde para esta sessão
                val heartRateData = simulateHeartRateData(session)
                val oxygenData = simulateOxygenData(session)
                val snoringData = simulateSnoringData(session)
                val movementData = simulateMovementData(session)
                
                // Dados da sessão para análise
                val sessionData = SleepDataDto(
                    date = session.startTime.format(dateFormatter),
                    totalSleep = "${session.duration.toHours()}h${session.duration.toMinutesPart()}min",
                    deepSleepPercentage = session.deepSleepPercentage,
                    remSleepPercentage = session.remSleepPercentage,
                    lightSleepPercentage = session.lightSleepPercentage,
                    wakeCount = session.wakeDuringNightCount,
                    efficiency = session.efficiency,
                    heartRateAvg = heartRateData.average,
                    heartRateMin = heartRateData.min,
                    heartRateMax = heartRateData.max,
                    oxygenSaturation = oxygenData,
                    snoring = snoringData.detected,
                    snoringDuration = snoringData.duration,
                    movementCount = movementData,
                    bedtime = session.startTime.format(timeFormatter),
                    wakeupTime = session.endTime.format(timeFormatter),
                    isDataEstimated = session.stages.isEmpty()
                )
                
                // Simular ciclos de sono detalhados se não houver dados reais
                val sleepStagesDetail = createSleepStagesDetail(session)
                
                // Gerar métricas de saúde
                val healthMetrics = HealthMetrics(
                    averageHeartRate = heartRateData.average,
                    minHeartRate = heartRateData.min,
                    maxHeartRate = heartRateData.max,
                    oxygenSaturation = oxygenData,
                    snoringDetected = snoringData.detected,
                    snoringDuration = if (snoringData.duration > 0) "${snoringData.duration} min" else null,
                    movementCount = movementData
                )
                
                // Calcular pontuação de sono para esta noite
                val sleepScore = calculateSleepScore(session, healthMetrics)
                val sleepQuality = getSleepQualityLabel(sleepScore)
                
                // Gerar fato científico personalizado
                val scientificFact = generateScientificFact(session, sleepStagesDetail)
                
                // Construir prompt para análise diária avançada
                val dailyPrompt = buildAdvancedDailyPrompt(sessionData, sleepStagesDetail, healthMetrics)
                val dailyResponse = callAIApi(dailyPrompt)
                
                try {
                    // Tentar processar a resposta da IA
                    val basicAnalysis = gson.fromJson(dailyResponse, DailyAnalysis::class.java)
                    
                    // Criar análise completa com todos os dados
                    DailyAnalysis(
                        date = session.startTime.format(dateFormatter),
                        analysis = basicAnalysis.analysis,
                        recommendations = basicAnalysis.recommendations,
                        sleepScore = sleepScore,
                        sleepQuality = sleepQuality,
                        sleepStages = sleepStagesDetail,
                        scientificFact = scientificFact,
                        healthMetrics = healthMetrics,
                        naps = findNapsForDay(naps, session.startTime)
                    )
                } catch (e: Exception) {
                    // Fallback se a análise da IA falhar
                    DailyAnalysis(
                        date = session.startTime.format(dateFormatter),
                        analysis = "Análise detalhada não disponível para esta noite.",
                        recommendations = listOf("Tente registrar mais detalhes sobre seu sono."),
                        sleepScore = sleepScore,
                        sleepQuality = sleepQuality,
                        sleepStages = sleepStagesDetail,
                        scientificFact = scientificFact,
                        healthMetrics = healthMetrics,
                        naps = findNapsForDay(naps, session.startTime)
                    )
                }
            }
            
            // Calcular pontuação média semanal
            val weeklyScore = dailyAnalyses.mapNotNull { it.sleepScore }.average().toInt().takeIf { !it.isNaN() }
            val weeklyQuality = weeklyScore?.let { getSleepQualityLabel(it) }
            
            // Gerar análise geral da semana com prompt avançado
            val prompt = buildAdvancedWeeklyPrompt(sleepData, dailyAnalyses, naps)
            val response = callAIApi(prompt)
            
            val weeklyAdvice = try {
                gson.fromJson(response, WeeklyAdvice::class.java)
            } catch (e: Exception) {
                WeeklyAdvice(
                    tips = listOf("Mantenha um horário regular para dormir e acordar.", 
                                "Reduza a exposição à luz azul antes de dormir."),
                    warnings = emptyList(),
                    positiveReinforcement = "Continue registrando seu sono para análises mais precisas.",
                    sleepScore = weeklyScore,
                    sleepQuality = weeklyQuality
                )
            }
            
            // Gerar recomendação de horário ideal para sonecas
            val recommendedNapTime = generateRecommendedNapTime(weekSessions)
            
            // Gerar fato científico semanal
            val weeklyScientificFact = generateWeeklyScientificFact(weekSessions, dailyAnalyses)
            
            // Combinar análise semanal com análises diárias em uma resposta completa
            SleepAdvice(
                tips = weeklyAdvice.tips,
                warnings = weeklyAdvice.warnings,
                positiveReinforcement = weeklyAdvice.positiveReinforcement,
                dailyAnalysis = dailyAnalyses,
                weeklyScore = weeklyScore,
                weeklyQuality = weeklyQuality,
                weeklyTrend = weeklyAdvice.weeklyTrend ?: detectSleepTrend(weekSessions),
                scientificFact = weeklyScientificFact,
                recommendedNapTime = recommendedNapTime
            )
        } catch (e: Exception) {
            // Resposta de fallback em caso de erro
            SleepAdvice(
                tips = listOf("Mantenha um horário regular para dormir e acordar.", 
                            "Crie um ambiente propício para o sono no seu quarto."),
                warnings = emptyList(),
                positiveReinforcement = "Continue registrando seu sono para análises mais precisas.",
                dailyAnalysis = emptyList(),
                scientificFact = "O sono REM é essencial para a consolidação da memória e regulação emocional."
            )
        }
    }
    
    /**
     * Chamada à API de IA para análise de dados de sono
     * Implementação local que simula respostas da IA
     * Em uma implementação real, este método faria chamadas a uma API como OpenAI GPT-4.5/4o, Google Vertex AI (Gemini) ou Anthropic Claude 3
     */
    private suspend fun callAIApi(prompt: String): String {
        // Implementação local que não depende de API externa
        return when {
            prompt.contains("Prompt Avançado para Análise Semanal") || prompt.contains("Prompt Avançado para Análise Inteligente") -> {
                // Resposta para análise semanal avançada
                """
                {
                    "tips": [
                        "Baseado nos seus padrões de sono, tente dormir até 22:45. Suas melhores fases de sono profundo ocorrem entre 23h e 1h.",
                        "Seus dados mostram que você tem melhor qualidade de sono em dias sem uso de telas à noite. Evite dispositivos eletrônicos 90 minutos antes de dormir.",
                        "Seus despertares noturnos ocorrem principalmente entre 3h-4h. Considere reduzir a ingestão de líquidos após 20h para minimizar a necessidade de levantar."
                    ],
                    "warnings": [
                        "Sua quantidade de sono profundo está 15% abaixo do ideal, o que pode estar afetando sua recuperação física e energia durante o dia.",
                        "Seus dados indicam uma possível fragmentação do sono com 3-4 despertares por noite, o que pode reduzir a eficácia do descanso."
                    ],
                    "positiveReinforcement": "Você tem mantido uma duração total de sono consistente de 7h30min, o que é excelente para a saúde geral!",
                    "weeklyTrend": "Sua eficiência de sono melhorou 8% nos últimos 3 dias, possivelmente relacionada ao horário mais regular para dormir."
                }
                """
            }
            prompt.contains("Prompt Avançado para Análise Diária") -> {
                // Extrair a data da solicitação para personalizar a resposta
                val date = try {
                    if (prompt.contains("date")) {
                        val dateRegex = "\"date\":\s*\"([^\"]+)\"".toRegex()
                        val match = dateRegex.find(prompt)
                        match?.groupValues?.get(1) ?: "data não encontrada"
                    } else {
                        "data não encontrada"
                    }
                } catch (e: Exception) {
                    "data não encontrada"
                }
                
                // Verificar se há ronco nos dados
                val hasSnoring = prompt.contains("snoringDetected") && prompt.contains("true")
                
                // Verificar se o sono profundo está baixo
                val lowDeepSleep = try {
                    if (prompt.contains("deepPercentage")) {
                        val deepRegex = "\"deepPercentage\":\s*([0-9.]+)".toRegex()
                        val match = deepRegex.find(prompt)
                        val percentage = match?.groupValues?.get(1)?.toDoubleOrNull() ?: 20.0
                        percentage < 18.0
                    } else {
                        false
                    }
                } catch (e: Exception) {
                    false
                }
                
                // Resposta para análise diária personalizada
                val analysis = when {
                    hasSnoring && lowDeepSleep -> 
                        "Nesta noite de $date, sua qualidade de sono foi comprometida por ronco detectado e baixa porcentagem de sono profundo (abaixo de 18%). Isso pode explicar por que você acordou se sentindo menos descansado."
                    hasSnoring -> 
                        "Nesta noite de $date, detectamos episódios de ronco que podem ter afetado a qualidade do seu sono, embora os estágios de sono estejam relativamente equilibrados."
                    lowDeepSleep -> 
                        "Nesta noite de $date, você teve menos sono profundo que o ideal, o que pode afetar sua recuperação física e sensação de descanso ao acordar."
                    else -> 
                        "Nesta noite de $date, seu sono apresentou uma distribuição de estágios equilibrada, com transições suaves entre ciclos. Sua eficiência de sono foi boa, apesar de alguns breves despertares."
                }
                
                val recommendations = when {
                    hasSnoring -> 
                        listOf(
                            "Experimente dormir de lado em vez de barriga para cima para reduzir episódios de ronco.",
                            "Considere usar uma fita nasal ou dilatador nasal para melhorar a respiração durante o sono."
                        )
                    lowDeepSleep -> 
                        listOf(
                            "Para aumentar seu sono profundo, tente fazer exercícios físicos pelo menos 6 horas antes de dormir.",
                            "Mantenha seu quarto mais fresco (18-20°C) para promover melhor sono profundo."
                        )
                    else -> 
                        listOf(
                            "Continue mantendo um horário regular para dormir e acordar para preservar seu bom padrão de sono.",
                            "Considere técnicas de relaxamento como respiração profunda antes de dormir para melhorar ainda mais a qualidade do sono."
                        )
                }
                
                """
                {
                    "analysis": "$analysis",
                    "recommendations": ${gson.toJson(recommendations)}
                }
                """
            }
            else -> {
                // Resposta padrão mais detalhada
                """
                {
                    "tips": [
                        "Mantenha um horário regular para dormir e acordar, mesmo nos fins de semana.", 
                        "Crie um ambiente ideal para o sono: escuro, silencioso e com temperatura agradavelmente fresca.",
                        "Evite cafeína, álcool e refeições pesadas nas horas que antecedem o sono."
                    ],
                    "warnings": [
                        "Atenção à fragmentação do sono, que pode reduzir a qualidade do descanso mesmo com duração adequada."
                    ],
                    "positiveReinforcement": "Continue registrando seu sono para obter análises mais personalizadas e precisas!",
                    "weeklyTrend": "Dados insuficientes para determinar uma tendência clara."
                }
                """
            }
        }
    }
    /**
{{ ... }}
     * Constrói um prompt avançado para análise semanal de sono
     */
    private fun buildAdvancedWeeklyPrompt(sleepData: List<SleepDataDto>, dailyAnalyses: List<DailyAnalysis>, naps: List<NapData>): String {
        val jsonData = gson.toJson(sleepData)
        val napData = gson.toJson(naps)
        
        return """
            ## 💭 Prompt Avançado para Análise Inteligente do Sono com IA
            
            Analise os seguintes dados de sono da última semana e forneça:
            1. 2-3 dicas práticas e específicas para melhorar o sono baseadas nos padrões observados
            2. Avisos sobre padrões preocupantes (se houver)
            3. Reforço positivo se houver melhora ou bons padrões
            4. Tendência semanal do sono (melhorando, piorando ou estável)
            
            ### Dados de Sono:
            $jsonData
            
            ### Dados de Sonecas (se houver):
            $napData
            
            Responda em formato JSON com as seguintes chaves:
            {
                "tips": ["dica1", "dica2", ...],
                "warnings": ["aviso1", "aviso2", ...],
                "positiveReinforcement": "mensagem de reforço positivo ou null",
                "weeklyTrend": "descrição da tendência semanal"
            }
            
            Seja específico e prático nas dicas. Evite recomendações genéricas.
            Baseie suas recomendações em padrões reais detectados nos dados.
            Considere fatores como:
            - Distribuição dos estágios do sono (ideal: Profundo > 20%, REM > 20%, Leve ~55%)
            - Frequência cardíaca durante o sono
            - Saturação de oxigênio
            - Ronco e apneia
            - Movimentos noturnos
            - Horários de deitar e acordar
            - Sonecas durante o dia
        """.trimIndent()
    }
    
    /**
     * Constrói um prompt avançado para análise diária de sono
     */
    private fun buildAdvancedDailyPrompt(sleepData: SleepDataDto, sleepStages: SleepStagesDetail, healthMetrics: HealthMetrics): String {
        val jsonData = gson.toJson(sleepData)
        val stagesData = gson.toJson(sleepStages)
        val metricsData = gson.toJson(healthMetrics)
        
        return """
            ## 💭 Prompt Avançado para Análise Diária do Sono com IA
            
            Analise os seguintes dados de uma noite de sono:
            
            ### Dados Básicos:
            $jsonData
            
            ### Estágios do Sono:
            $stagesData
            
            ### Métricas de Saúde:
            $metricsData
            
            Forneça:
            1. Uma análise curta e específica desta noite de sono
            2. 1-2 recomendações práticas baseadas exclusivamente nesta noite
            
            Considere:
            - Eficiência do sono (ideal > 85%)
            - Distribuição dos estágios do sono (ideal: Profundo > 20%, REM > 20%, Leve ~55%)
            - Número de despertares durante a noite
            - Duração total do sono (ideal: 7-9 horas)
            - Frequência cardíaca durante o sono
            - Presença de ronco ou apneia
            - Movimentos durante o sono
            - Horário de dormir e acordar
            
            Responda em formato JSON com as seguintes chaves:
            {
                "analysis": "Análise curta e específica desta noite",
                "recommendations": ["recomendação1", "recomendação2"]
            }
            
    }
    
    /**
     * Simula dados de saturação de oxigênio durante o sono
     */
    private fun simulateOxygenData(session: SleepSession): Int {
        // Saturação de oxigênio normal: 95-100%
        val baseOxygen = 97
        
        // Ajustes baseados na eficiência e estágios do sono
        val efficiencyFactor = (session.efficiency - 80) / 20
        val deepSleepFactor = (session.deepSleepPercentage - 20) / 10
        
        // Valor final
        return (baseOxygen + efficiencyFactor + deepSleepFactor).toInt().coerceIn(92, 99)
    }
    
    /**
     * Classe auxiliar para dados de frequência cardíaca
     */
    data class HeartRateData(val average: Int, val min: Int, val max: Int)
    
    /**
     * Classe auxiliar para dados de ronco
     */
    data class SnoringData(val detected: Boolean, val duration: Int)
    
    /**
     * Simula dados de frequência cardíaca durante o sono
     */
    private fun simulateHeartRateData(session: SleepSession): HeartRateData {
        // Em uma implementação real, esses dados viriam do Health Connect
        // Aqui estamos simulando valores realistas baseados na duração e qualidade do sono
        
        // Frequência cardíaca média durante o sono: tipicamente entre 50-70 bpm
        val baseAverage = 60
        
        // Ajustes baseados na eficiência do sono
        val efficiencyFactor = (session.efficiency - 75) / 10
        
        // Valores finais
        val average = (baseAverage - efficiencyFactor).toInt().coerceIn(50, 80)
        val min = (average - 10 - (Math.random() * 5).toInt()).coerceIn(40, 60)
        val max = (average + 15 + (Math.random() * 10).toInt()).coerceIn(70, 100)
        
        return HeartRateData(average, min, max)
    }
    
    /**
     * Simula dados de ronco durante o sono
     */
    private fun simulateSnoringData(session: SleepSession): SnoringData {
        // Probabilidade base de ronco: 30%
        val snoreProbability = 0.3
        
        // Fatores que aumentam a probabilidade de ronco
        val deepSleepFactor = if (session.deepSleepPercentage < 15) 0.2 else 0.0
        val efficiencyFactor = if (session.efficiency < 75) 0.2 else 0.0
        
        // Probabilidade final
        val finalProbability = snoreProbability + deepSleepFactor + efficiencyFactor
        
        // Determina se houve ronco
        val detected = Math.random() < finalProbability
        
        // Se houve ronco, calcula a duração
        val duration = if (detected) {
            val totalMinutes = session.duration.toMinutes()
            (totalMinutes * (0.1 + Math.random() * 0.2)).toInt() // 10-30% do tempo total
        } else 0
        
        return SnoringData(detected, duration)
    }
    
    /**
     * Simula dados de movimento durante o sono
     */
    private fun simulateMovementData(session: SleepSession): Int {
        // Movimentos base durante o sono: 10-30 por noite
        val baseMovements = 20
        
        // Fatores que afetam o número de movimentos
        val durationFactor = (session.duration.toHours() - 7) * 2
        val efficiencyFactor = (80 - session.efficiency) / 5
        val remFactor = (session.remSleepPercentage - 20) * (-0.5)
        
        // Valor final com alguma aleatoriedade
        return (baseMovements + durationFactor + efficiencyFactor + remFactor + (Math.random() * 10 - 5)).toInt().coerceIn(5, 50)
    }
    
    /**
     * Cria detalhes dos estágios de sono a partir de uma sessão
     */
    private fun createSleepStagesDetail(session: SleepSession): SleepStagesDetail {
        val totalMinutes = session.duration.toMinutes().toDouble()
        
        // Se há estágios reais, use-os
        if (session.stages.isNotEmpty()) {
            val lightMinutes = session.stages.filter { it.type == SleepStageType.LIGHT }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
                
            val deepMinutes = session.stages.filter { it.type == SleepStageType.DEEP }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
                
            val remMinutes = session.stages.filter { it.type == SleepStageType.REM }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
                
            val awakeMinutes = session.stages.filter { it.type == SleepStageType.AWAKE }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
            
            // Calcular porcentagens
            val lightPercentage = if (totalMinutes > 0) (lightMinutes.toDouble() / totalMinutes) * 100 else 0.0
            val deepPercentage = if (totalMinutes > 0) (deepMinutes.toDouble() / totalMinutes) * 100 else 0.0
            val remPercentage = if (totalMinutes > 0) (remMinutes.toDouble() / totalMinutes) * 100 else 0.0
            val awakePercentage = if (totalMinutes > 0) (awakeMinutes.toDouble() / totalMinutes) * 100 else 0.0
            
            return SleepStagesDetail(
                light = formatDuration(Duration.ofMinutes(lightMinutes)),
                deep = formatDuration(Duration.ofMinutes(deepMinutes)),
                rem = formatDuration(Duration.ofMinutes(remMinutes)),
                awake = formatDuration(Duration.ofMinutes(awakeMinutes)),
                lightPercentage = lightPercentage,
                deepPercentage = deepPercentage,
                remPercentage = remPercentage,
                awakePercentage = awakePercentage,
                isEstimated = false
            )
        } else {
            // Simular estágios baseados em distribuições típicas
            // Distribuição típica: 55% sono leve, 20% sono profundo, 20% REM, 5% acordado
            val lightMinutes = (totalMinutes * 0.55).toLong()
            val deepMinutes = (totalMinutes * 0.20).toLong()
            val remMinutes = (totalMinutes * 0.20).toLong()
            val awakeMinutes = totalMinutes.toLong() - lightMinutes - deepMinutes - remMinutes
            
            return SleepStagesDetail(
                light = formatDuration(Duration.ofMinutes(lightMinutes)),
                deep = formatDuration(Duration.ofMinutes(deepMinutes)),
                rem = formatDuration(Duration.ofMinutes(remMinutes)),
                awake = formatDuration(Duration.ofMinutes(awakeMinutes)),
                lightPercentage = 55.0,
                deepPercentage = 20.0,
                remPercentage = 20.0,
                awakePercentage = 5.0,
                isEstimated = true
            )
        }
    }
    
    /**
     * Formata uma duração em formato legível
     */
    private fun formatDuration(duration: Duration): String {
        val hours = duration.toHours()
        val minutes = duration.toMinutesPart()
        return if (hours > 0) {
            "${hours}h${minutes}min"
        } else {
            "${minutes}min"
        }
    }
    
    /**
     * Detecta sonecas (naps) a partir das sessões de sono
     */
    private fun detectNaps(sessions: List<SleepSession>): List<NapData> {
        val naps = mutableListOf<NapData>()
        
        // Considera como soneca qualquer sessão de sono com menos de 3 horas de duração
        // que ocorre entre 9h e 18h
        for (session in sessions) {
            val hour = session.startTime.hour
            val duration = session.duration
            
            if (hour in 9..18 && duration.toHours() < 3) {
                // Qualidade da soneca baseada na duração (ideal: 20-30 minutos ou 90 minutos)
                val durationMinutes = duration.toMinutes()
                val quality = when {
                    durationMinutes in 15..30 -> "Boa"
                    durationMinutes in 85..95 -> "Excelente"
                    durationMinutes > 30 && durationMinutes < 85 -> "Regular"
                    durationMinutes > 95 -> "Longa demais"
                    else -> "Curta demais"
                }
                
                // Determina se a soneca foi restauradora
                val isRestorative = quality in listOf("Boa", "Excelente")
                
                naps.add(NapData(
                    startTime = session.startTime.format(timeFormatter),
                    endTime = session.endTime.format(timeFormatter),
                    duration = formatDuration(duration),
                    quality = quality,
                    isRestorative = isRestorative
                ))
            }
        }
        
        return naps
    }
    
    /**
     * Encontra sonecas para um dia específico
     */
    private fun findNapsForDay(naps: List<NapData>, date: ZonedDateTime): List<NapData> {
        // Em uma implementação real, filtraríamos por data
        // Aqui estamos retornando todas as sonecas para simplificar
        return naps
    }
    
    /**
     * Calcula a pontuação de qualidade do sono (0-100)
     */
    private fun calculateSleepScore(session: SleepSession, healthMetrics: HealthMetrics): Int {
        // Base: eficiência do sono já calculada (0-100)
        var score = session.efficiency
        
        // Ajustes baseados em métricas de saúde
        
        // Frequência cardíaca: ideal é ter uma boa variação entre mínima e máxima
        val heartRateVariation = (healthMetrics.maxHeartRate ?: 0) - (healthMetrics.minHeartRate ?: 0)
        if (heartRateVariation > 20) score += 5 else if (heartRateVariation < 10) score -= 5
        
        // Saturação de oxigênio: ideal > 95%
        val oxygen = healthMetrics.oxygenSaturation ?: 0
        when {
            oxygen >= 97 -> score += 5
            oxygen >= 95 -> score += 2
            oxygen < 93 -> score -= 10
        }
        
        // Ronco: penalidade se detectado
        if (healthMetrics.snoringDetected == true) score -= 5
        
        // Movimentos: ideal é ter poucos movimentos
        val movements = healthMetrics.movementCount ?: 0
        when {
            movements < 15 -> score += 3
            movements > 30 -> score -= 3
        }
        
        return score.toInt().coerceIn(0, 100)
    }
    
    /**
     * Obtém a classificação verbal da qualidade do sono
     */
    private fun getSleepQualityLabel(score: Int): String {
        return when {
            score >= 90 -> "Excelente"
            score >= 80 -> "Muito Boa"
            score >= 70 -> "Boa"
            score >= 60 -> "Regular"
            score >= 50 -> "Razoável"
            score >= 40 -> "Insatisfatória"
            else -> "Ruim"
        }
    }
    
    /**
     * Gera um fato científico personalizado baseado nos dados de sono
     */
    private fun generateScientificFact(session: SleepSession, sleepStages: SleepStagesDetail): String {
        // Lista de fatos científicos sobre o sono
        val facts = listOf(
            "O sono REM está ligado à regulação emocional e ao processamento de memórias.",
            "Durante o sono profundo, o cérebro consolida memórias e o corpo libera hormônio do crescimento.",
            "Um ciclo completo de sono dura cerca de 90 minutos, passando por estágios leve, profundo e REM.",
            "A melatonina, hormônio que regula o sono, é suprimida pela luz azul de telas.",
            "Adultos precisam em média de 7-9 horas de sono por noite para funções cognitivas ótimas.",
            "O sono profundo é essencial para a recuperação física do corpo.",
            "A temperatura ideal do quarto para dormir é entre 18-20°C.",
            "Durante o sono REM, o corpo fica temporariamente paralísado para evitar que atuemos nossos sonhos."
        )
        
        // Seleciona um fato baseado nos dados de sono
        return when {
            sleepStages.remPercentage > 25 -> 
                "Você teve ${sleepStages.rem} de sono REM (${sleepStages.remPercentage.toInt()}%), acima da média. O sono REM é essencial para a consolidação da memória e criatividade."
            
            sleepStages.deepPercentage > 25 -> 
                "Você teve ${sleepStages.deep} de sono profundo (${sleepStages.deepPercentage.toInt()}%), acima da média. O sono profundo é quando ocorre a maior parte da recuperação física."
            
            sleepStages.deepPercentage < 15 -> 
                "Você teve apenas ${sleepStages.deep} de sono profundo (${sleepStages.deepPercentage.toInt()}%). O sono profundo é essencial para a recuperação física e imunidade."
            
            sleepStages.remPercentage < 15 -> 
                "Você teve apenas ${sleepStages.rem} de sono REM (${sleepStages.remPercentage.toInt()}%). O sono REM é importante para a saúde mental e processamento emocional."
            
            session.duration.toHours() > 9 -> 
                "Você dormiu mais de 9 horas. Embora o sono seja importante, dormir demais regularmente pode estar associado a problemas de saúde."
            
            session.duration.toHours() < 6 -> 
                "Você dormiu menos de 6 horas. A privação crônica de sono pode afetar negativamente a memória, humor e imunidade."
            
            else -> facts.random()
        }
    }
    
    /**
     * Gera um fato científico semanal baseado nos dados de sono
     */
    private fun generateWeeklyScientificFact(sessions: List<SleepSession>, dailyAnalyses: List<DailyAnalysis>): String {
        // Calcula a média de horas dormidas
        val avgHours = sessions.map { it.duration.toHours() }.average()
        
        // Calcula a média de cada estágio do sono
        val avgDeepPercentage = sessions.map { it.deepSleepPercentage }.average()
        val avgRemPercentage = sessions.map { it.remSleepPercentage }.average()
        
        return when {
            avgHours < 6.5 -> 
                "Na última semana, você dormiu em média ${String.format("%.1f", avgHours)} horas por noite. Estudos mostram que dormir menos de 7 horas regularmente aumenta o risco de problemas de saúde."
            
            avgDeepPercentage < 15 -> 
                "Sua média de sono profundo foi de ${String.format("%.1f", avgDeepPercentage)}%, abaixo do ideal. O sono profundo é essencial para a recuperação física e imunidade."
            
            avgRemPercentage < 15 -> 
                "Sua média de sono REM foi de ${String.format("%.1f", avgRemPercentage)}%, abaixo do ideal. O sono REM é crucial para a saúde mental, aprendizado e memória."
            
            avgHours >= 7 && avgHours <= 9 && avgDeepPercentage >= 20 && avgRemPercentage >= 20 -> 
                "Parabéns! Seus padrões de sono estão próximos do ideal, com boa duração e distribuição de estágios. Isso contribui para melhor saúde física e mental."
            
            else -> 
                "Sabia que o sono segue ciclos de aproximadamente 90 minutos? Um adulto típico passa por 4-6 ciclos por noite, cada um com estágios de sono leve, profundo e REM."
        }
    }
    
    /**
     * Detecta a tendência de sono ao longo da semana
     */
    private fun detectSleepTrend(sessions: List<SleepSession>): String {
        if (sessions.size < 3) return "Dados insuficientes para detectar tendência"
        
        // Ordena sessões por data
        val sortedSessions = sessions.sortedBy { it.startTime }
        
        // Analisa tendência de eficiência
        val firstHalf = sortedSessions.take(sortedSessions.size / 2)
        val secondHalf = sortedSessions.drop(sortedSessions.size / 2)
        
        val firstHalfEfficiency = firstHalf.map { it.efficiency }.average()
        val secondHalfEfficiency = secondHalf.map { it.efficiency }.average()
        
        val efficiencyDiff = secondHalfEfficiency - firstHalfEfficiency
        
        return when {
            efficiencyDiff > 5 -> "Sua qualidade de sono está melhorando ao longo da semana"
            efficiencyDiff < -5 -> "Sua qualidade de sono está piorando ao longo da semana"
            else -> "Sua qualidade de sono está estável ao longo da semana"
        }
    }
    
    /**
     * Gera recomendação de horário ideal para sonecas
     */
    private fun generateRecommendedNapTime(sessions: List<SleepSession>): String {
        // Analisa horários de dormir e acordar para recomendar melhor horário para soneca
        val avgWakeupTime = sessions.map { it.endTime.hour + it.endTime.minute / 60.0 }.average()
        
        // Recomenda soneca entre 6-8 horas após acordar, ou entre 13h-15h
        val recommendedHour = if (avgWakeupTime > 0) {
            val napTime = (avgWakeupTime + 7).coerceIn(13.0, 15.0)
            napTime
        } else {
            14.0 // Horário padrão se não houver dados suficientes
        }
        
        val hour = recommendedHour.toInt()
        val minute = ((recommendedHour - hour) * 60).toInt()
        
        return String.format("%02d:%02d", hour, minute)
    }
    
    private fun parseAIResponse(response: String): SleepAdvice {
        return try {
            val weeklyAdvice = gson.fromJson(response, WeeklyAdvice::class.java)
            SleepAdvice(
                tips = weeklyAdvice.tips,
                warnings = weeklyAdvice.warnings,
                positiveReinforcement = weeklyAdvice.positiveReinforcement,
                dailyAnalysis = emptyList() // Será preenchido separadamente
            )
        } catch (e: Exception) {
            SleepAdvice(
                tips = listOf("Erro ao processar a resposta da IA."),
                warnings = emptyList(),
                positiveReinforcement = null,
                dailyAnalysis = emptyList()
            )
        }
    }
}

/**
 * DTO com dados detalhados de sono para análise pela IA
 */
data class SleepDataDto(
    @SerializedName("date") val date: String,
    @SerializedName("totalSleep") val totalSleep: String,
    @SerializedName("deepSleepPercentage") val deepSleepPercentage: Double,
    @SerializedName("remSleepPercentage") val remSleepPercentage: Double,
    @SerializedName("lightSleepPercentage") val lightSleepPercentage: Double,
    @SerializedName("wakeCount") val wakeCount: Int,
    @SerializedName("efficiency") val efficiency: Double,
    @SerializedName("heartRateAvg") val heartRateAvg: Int? = null,
    @SerializedName("heartRateMin") val heartRateMin: Int? = null,
    @SerializedName("heartRateMax") val heartRateMax: Int? = null,
    @SerializedName("oxygenSaturation") val oxygenSaturation: Int? = null,
    @SerializedName("snoring") val snoring: Boolean? = null,
    @SerializedName("snoringDuration") val snoringDuration: Int? = null,
    @SerializedName("movementCount") val movementCount: Int? = null,
    @SerializedName("bedtime") val bedtime: String? = null,
    @SerializedName("wakeupTime") val wakeupTime: String? = null,
    @SerializedName("isDataEstimated") val isDataEstimated: Boolean = false
)

/**
 * Resposta da análise semanal de sono
 */
data class WeeklyAdvice(
    val tips: List<String>,
    val warnings: List<String>,
    val positiveReinforcement: String?,
    val weeklyTrend: String? = null,
    val sleepScore: Int? = null,
    val sleepQuality: String? = null
)

/**
 * Análise detalhada de uma noite de sono
 */
data class DailyAnalysis(
    val date: String,
    val analysis: String,
    val recommendations: List<String>,
    val sleepScore: Int? = null,
    val sleepQuality: String? = null,
    val sleepStages: SleepStagesDetail? = null,
    val scientificFact: String? = null,
    val healthMetrics: HealthMetrics? = null,
    val naps: List<NapData>? = null
)

/**
 * Detalhes sobre os estágios do sono
 */
data class SleepStagesDetail(
    val light: String,
    val deep: String,
    val rem: String,
    val awake: String,
    val lightPercentage: Double,
    val deepPercentage: Double,
    val remPercentage: Double,
    val awakePercentage: Double,
    val isEstimated: Boolean = false
)

/**
 * Métricas de saúde durante o sono
 */
data class HealthMetrics(
    val averageHeartRate: Int? = null,
    val minHeartRate: Int? = null,
    val maxHeartRate: Int? = null,
    val oxygenSaturation: Int? = null,
    val snoringDetected: Boolean? = null,
    val snoringDuration: String? = null,
    val movementCount: Int? = null
)

/**
 * Dados sobre sonecas (naps)
 */
data class NapData(
    val startTime: String,
    val endTime: String,
    val duration: String,
    val quality: String,
    val isRestorative: Boolean
)

/**
 * Resposta completa da análise de sono com dicas e análises diárias
 */
data class SleepAdvice(
    val tips: List<String>,
    val warnings: List<String>,
    val positiveReinforcement: String?,
    val dailyAnalysis: List<DailyAnalysis>,
    val weeklyScore: Int? = null,
    val weeklyQuality: String? = null,
    val weeklyTrend: String? = null,
    val scientificFact: String? = null,
    val recommendedNapTime: String? = null
)