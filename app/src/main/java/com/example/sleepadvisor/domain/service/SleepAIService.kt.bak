package com.example.sleepadvisor.domain.service

import com.example.sleepadvisor.domain.model.SleepSession
import com.example.sleepadvisor.domain.model.SleepStage
import com.example.sleepadvisor.domain.model.SleepStageType
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import java.time.Duration
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Servi√ßo que utiliza IA avan√ßada para gerar an√°lises detalhadas e dicas personalizadas de sono
 * Integra dados do Health Connect e utiliza algoritmos de simula√ß√£o para est√°gios do sono
 */
@Singleton
class SleepAIService @Inject constructor(
    private val okHttpClient: OkHttpClient,
    private val gson: Gson
) {
    private val dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    private val timeFormatter = DateTimeFormatter.ofPattern("HH:mm")
    
    /**
     * Gera dicas personalizadas e an√°lises detalhadas baseadas nos dados de sono da √∫ltima semana
     * Inclui an√°lises individualizadas por noite, simula√ß√£o de ciclos de sono, e m√©tricas de sa√∫de
     */
    suspend fun generateSleepAdvice(weekSessions: List<SleepSession>): SleepAdvice = withContext(Dispatchers.IO) {
        try {
            if (weekSessions.isEmpty()) {
                return@withContext SleepAdvice(
                    tips = listOf("Registre seu sono por alguns dias para receber dicas personalizadas."),
                    warnings = emptyList(),
                    positiveReinforcement = null,
                    dailyAnalysis = emptyList(),
                    scientificFact = "Sabia que o sono √© dividido em 4-6 ciclos de 90 minutos cada? Cada ciclo passa por est√°gios leve, profundo e REM."
                )
            }
            
            // Preparar dados para an√°lise geral com m√©tricas avan√ßadas
            val sleepData = weekSessions.map { session ->
                // Extrair dados de frequ√™ncia card√≠aca e outros dados de sa√∫de (simulados por enquanto)
                // Em uma implementa√ß√£o real, esses dados viriam do Health Connect
                val heartRateData = simulateHeartRateData(session)
                val oxygenData = simulateOxygenData(session)
                val snoringData = simulateSnoringData(session)
                val movementData = simulateMovementData(session)
                
                SleepDataDto(
                    date = session.startTime.format(dateFormatter),
                    totalSleep = "${session.duration.toHours()}h${session.duration.toMinutesPart()}min",
                    deepSleepPercentage = session.deepSleepPercentage,
                    remSleepPercentage = session.remSleepPercentage,
                    lightSleepPercentage = session.lightSleepPercentage,
                    wakeCount = session.wakeDuringNightCount,
                    efficiency = session.efficiency,
                    heartRateAvg = heartRateData.average,
                    heartRateMin = heartRateData.min,
                    heartRateMax = heartRateData.max,
                    oxygenSaturation = oxygenData,
                    snoring = snoringData.detected,
                    snoringDuration = snoringData.duration,
                    movementCount = movementData,
                    bedtime = session.startTime.format(timeFormatter),
                    wakeupTime = session.endTime.format(timeFormatter),
                    isDataEstimated = session.stages.isEmpty()
                )
            }
            
            // Verificar se h√° sonecas registradas
            val naps = detectNaps(weekSessions)
            
            // Gerar an√°lise detalhada para cada noite com ciclos de sono simulados
            val dailyAnalyses = weekSessions.map { session ->
                // Extrair dados de sa√∫de para esta sess√£o
                val heartRateData = simulateHeartRateData(session)
                val oxygenData = simulateOxygenData(session)
                val snoringData = simulateSnoringData(session)
                val movementData = simulateMovementData(session)
                
                // Dados da sess√£o para an√°lise
                val sessionData = SleepDataDto(
                    date = session.startTime.format(dateFormatter),
                    totalSleep = "${session.duration.toHours()}h${session.duration.toMinutesPart()}min",
                    deepSleepPercentage = session.deepSleepPercentage,
                    remSleepPercentage = session.remSleepPercentage,
                    lightSleepPercentage = session.lightSleepPercentage,
                    wakeCount = session.wakeDuringNightCount,
                    efficiency = session.efficiency,
                    heartRateAvg = heartRateData.average,
                    heartRateMin = heartRateData.min,
                    heartRateMax = heartRateData.max,
                    oxygenSaturation = oxygenData,
                    snoring = snoringData.detected,
                    snoringDuration = snoringData.duration,
                    movementCount = movementData,
                    bedtime = session.startTime.format(timeFormatter),
                    wakeupTime = session.endTime.format(timeFormatter),
                    isDataEstimated = session.stages.isEmpty()
                )
                
                // Simular ciclos de sono detalhados se n√£o houver dados reais
                val sleepStagesDetail = createSleepStagesDetail(session)
                
                // Gerar m√©tricas de sa√∫de
                val healthMetrics = HealthMetrics(
                    averageHeartRate = heartRateData.average,
                    minHeartRate = heartRateData.min,
                    maxHeartRate = heartRateData.max,
                    oxygenSaturation = oxygenData,
                    snoringDetected = snoringData.detected,
                    snoringDuration = if (snoringData.duration > 0) "${snoringData.duration} min" else null,
                    movementCount = movementData
                )
                
                // Calcular pontua√ß√£o de sono para esta noite
                val sleepScore = calculateSleepScore(session, healthMetrics)
                val sleepQuality = getSleepQualityLabel(sleepScore)
                
                // Gerar fato cient√≠fico personalizado
                val scientificFact = generateScientificFact(session, sleepStagesDetail)
                
                // Construir prompt para an√°lise di√°ria avan√ßada
                val dailyPrompt = buildAdvancedDailyPrompt(sessionData, sleepStagesDetail, healthMetrics)
                val dailyResponse = callAIApi(dailyPrompt)
                
                try {
                    // Tentar processar a resposta da IA
                    val basicAnalysis = gson.fromJson(dailyResponse, DailyAnalysis::class.java)
                    
                    // Criar an√°lise completa com todos os dados
                    DailyAnalysis(
                        date = session.startTime.format(dateFormatter),
                        analysis = basicAnalysis.analysis,
                        recommendations = basicAnalysis.recommendations,
                        sleepScore = sleepScore,
                        sleepQuality = sleepQuality,
                        sleepStages = sleepStagesDetail,
                        scientificFact = scientificFact,
                        healthMetrics = healthMetrics,
                        naps = findNapsForDay(naps, session.startTime)
                    )
                } catch (e: Exception) {
                    // Fallback se a an√°lise da IA falhar
                    DailyAnalysis(
                        date = session.startTime.format(dateFormatter),
                        analysis = "An√°lise detalhada n√£o dispon√≠vel para esta noite.",
                        recommendations = listOf("Tente registrar mais detalhes sobre seu sono."),
                        sleepScore = sleepScore,
                        sleepQuality = sleepQuality,
                        sleepStages = sleepStagesDetail,
                        scientificFact = scientificFact,
                        healthMetrics = healthMetrics,
                        naps = findNapsForDay(naps, session.startTime)
                    )
                }
            }
            
            // Calcular pontua√ß√£o m√©dia semanal
            val weeklyScore = dailyAnalyses.mapNotNull { it.sleepScore }.average().toInt().takeIf { !it.isNaN() }
            val weeklyQuality = weeklyScore?.let { getSleepQualityLabel(it) }
            
            // Gerar an√°lise geral da semana com prompt avan√ßado
            val prompt = buildAdvancedWeeklyPrompt(sleepData, dailyAnalyses, naps)
            val response = callAIApi(prompt)
            
            val weeklyAdvice = try {
                gson.fromJson(response, WeeklyAdvice::class.java)
            } catch (e: Exception) {
                WeeklyAdvice(
                    tips = listOf("Mantenha um hor√°rio regular para dormir e acordar.", 
                                "Reduza a exposi√ß√£o √† luz azul antes de dormir."),
                    warnings = emptyList(),
                    positiveReinforcement = "Continue registrando seu sono para an√°lises mais precisas.",
                    sleepScore = weeklyScore,
                    sleepQuality = weeklyQuality
                )
            }
            
            // Gerar recomenda√ß√£o de hor√°rio ideal para sonecas
            val recommendedNapTime = generateRecommendedNapTime(weekSessions)
            
            // Gerar fato cient√≠fico semanal
            val weeklyScientificFact = generateWeeklyScientificFact(weekSessions, dailyAnalyses)
            
            // Combinar an√°lise semanal com an√°lises di√°rias em uma resposta completa
            SleepAdvice(
                tips = weeklyAdvice.tips,
                warnings = weeklyAdvice.warnings,
                positiveReinforcement = weeklyAdvice.positiveReinforcement,
                dailyAnalysis = dailyAnalyses,
                weeklyScore = weeklyScore,
                weeklyQuality = weeklyQuality,
                weeklyTrend = weeklyAdvice.weeklyTrend ?: detectSleepTrend(weekSessions),
                scientificFact = weeklyScientificFact,
                recommendedNapTime = recommendedNapTime
            )
        } catch (e: Exception) {
            // Resposta de fallback em caso de erro
            SleepAdvice(
                tips = listOf("Mantenha um hor√°rio regular para dormir e acordar.", 
                            "Crie um ambiente prop√≠cio para o sono no seu quarto."),
                warnings = emptyList(),
                positiveReinforcement = "Continue registrando seu sono para an√°lises mais precisas.",
                dailyAnalysis = emptyList(),
                scientificFact = "O sono REM √© essencial para a consolida√ß√£o da mem√≥ria e regula√ß√£o emocional."
            )
        }
    }
    
    /**
     * Chamada √† API de IA para an√°lise de dados de sono
     * Implementa√ß√£o local que simula respostas da IA
     * Em uma implementa√ß√£o real, este m√©todo faria chamadas a uma API como OpenAI GPT-4.5/4o, Google Vertex AI (Gemini) ou Anthropic Claude 3
     */
    private suspend fun callAIApi(prompt: String): String {
        // Implementa√ß√£o local que n√£o depende de API externa
        return when {
            prompt.contains("Prompt Avan√ßado para An√°lise Semanal") || prompt.contains("Prompt Avan√ßado para An√°lise Inteligente") -> {
                // Resposta para an√°lise semanal avan√ßada
                """
                {
                    "tips": [
                        "Baseado nos seus padr√µes de sono, tente dormir at√© 22:45. Suas melhores fases de sono profundo ocorrem entre 23h e 1h.",
                        "Seus dados mostram que voc√™ tem melhor qualidade de sono em dias sem uso de telas √† noite. Evite dispositivos eletr√¥nicos 90 minutos antes de dormir.",
                        "Seus despertares noturnos ocorrem principalmente entre 3h-4h. Considere reduzir a ingest√£o de l√≠quidos ap√≥s 20h para minimizar a necessidade de levantar."
                    ],
                    "warnings": [
                        "Sua quantidade de sono profundo est√° 15% abaixo do ideal, o que pode estar afetando sua recupera√ß√£o f√≠sica e energia durante o dia.",
                        "Seus dados indicam uma poss√≠vel fragmenta√ß√£o do sono com 3-4 despertares por noite, o que pode reduzir a efic√°cia do descanso."
                    ],
                    "positiveReinforcement": "Voc√™ tem mantido uma dura√ß√£o total de sono consistente de 7h30min, o que √© excelente para a sa√∫de geral!",
                    "weeklyTrend": "Sua efici√™ncia de sono melhorou 8% nos √∫ltimos 3 dias, possivelmente relacionada ao hor√°rio mais regular para dormir."
                }
                """
            }
            prompt.contains("Prompt Avan√ßado para An√°lise Di√°ria") -> {
                // Extrair a data da solicita√ß√£o para personalizar a resposta
                val date = try {
                    if (prompt.contains("date")) {
                        val dateRegex = "\"date\":\s*\"([^\"]+)\"".toRegex()
                        val match = dateRegex.find(prompt)
                        match?.groupValues?.get(1) ?: "data n√£o encontrada"
                    } else {
                        "data n√£o encontrada"
                    }
                } catch (e: Exception) {
                    "data n√£o encontrada"
                }
                
                // Verificar se h√° ronco nos dados
                val hasSnoring = prompt.contains("snoringDetected") && prompt.contains("true")
                
                // Verificar se o sono profundo est√° baixo
                val lowDeepSleep = try {
                    if (prompt.contains("deepPercentage")) {
                        val deepRegex = "\"deepPercentage\":\s*([0-9.]+)".toRegex()
                        val match = deepRegex.find(prompt)
                        val percentage = match?.groupValues?.get(1)?.toDoubleOrNull() ?: 20.0
                        percentage < 18.0
                    } else {
                        false
                    }
                } catch (e: Exception) {
                    false
                }
                
                // Resposta para an√°lise di√°ria personalizada
                val analysis = when {
                    hasSnoring && lowDeepSleep -> 
                        "Nesta noite de $date, sua qualidade de sono foi comprometida por ronco detectado e baixa porcentagem de sono profundo (abaixo de 18%). Isso pode explicar por que voc√™ acordou se sentindo menos descansado."
                    hasSnoring -> 
                        "Nesta noite de $date, detectamos epis√≥dios de ronco que podem ter afetado a qualidade do seu sono, embora os est√°gios de sono estejam relativamente equilibrados."
                    lowDeepSleep -> 
                        "Nesta noite de $date, voc√™ teve menos sono profundo que o ideal, o que pode afetar sua recupera√ß√£o f√≠sica e sensa√ß√£o de descanso ao acordar."
                    else -> 
                        "Nesta noite de $date, seu sono apresentou uma distribui√ß√£o de est√°gios equilibrada, com transi√ß√µes suaves entre ciclos. Sua efici√™ncia de sono foi boa, apesar de alguns breves despertares."
                }
                
                val recommendations = when {
                    hasSnoring -> 
                        listOf(
                            "Experimente dormir de lado em vez de barriga para cima para reduzir epis√≥dios de ronco.",
                            "Considere usar uma fita nasal ou dilatador nasal para melhorar a respira√ß√£o durante o sono."
                        )
                    lowDeepSleep -> 
                        listOf(
                            "Para aumentar seu sono profundo, tente fazer exerc√≠cios f√≠sicos pelo menos 6 horas antes de dormir.",
                            "Mantenha seu quarto mais fresco (18-20¬∞C) para promover melhor sono profundo."
                        )
                    else -> 
                        listOf(
                            "Continue mantendo um hor√°rio regular para dormir e acordar para preservar seu bom padr√£o de sono.",
                            "Considere t√©cnicas de relaxamento como respira√ß√£o profunda antes de dormir para melhorar ainda mais a qualidade do sono."
                        )
                }
                
                """
                {
                    "analysis": "$analysis",
                    "recommendations": ${gson.toJson(recommendations)}
                }
                """
            }
            else -> {
                // Resposta padr√£o mais detalhada
                """
                {
                    "tips": [
                        "Mantenha um hor√°rio regular para dormir e acordar, mesmo nos fins de semana.", 
                        "Crie um ambiente ideal para o sono: escuro, silencioso e com temperatura agradavelmente fresca.",
                        "Evite cafe√≠na, √°lcool e refei√ß√µes pesadas nas horas que antecedem o sono."
                    ],
                    "warnings": [
                        "Aten√ß√£o √† fragmenta√ß√£o do sono, que pode reduzir a qualidade do descanso mesmo com dura√ß√£o adequada."
                    ],
                    "positiveReinforcement": "Continue registrando seu sono para obter an√°lises mais personalizadas e precisas!",
                    "weeklyTrend": "Dados insuficientes para determinar uma tend√™ncia clara."
                }
                """
            }
        }
    }
    /**
{{ ... }}
     * Constr√≥i um prompt avan√ßado para an√°lise semanal de sono
     */
    private fun buildAdvancedWeeklyPrompt(sleepData: List<SleepDataDto>, dailyAnalyses: List<DailyAnalysis>, naps: List<NapData>): String {
        val jsonData = gson.toJson(sleepData)
        val napData = gson.toJson(naps)
        
        return """
            ## üí≠ Prompt Avan√ßado para An√°lise Inteligente do Sono com IA
            
            Analise os seguintes dados de sono da √∫ltima semana e forne√ßa:
            1. 2-3 dicas pr√°ticas e espec√≠ficas para melhorar o sono baseadas nos padr√µes observados
            2. Avisos sobre padr√µes preocupantes (se houver)
            3. Refor√ßo positivo se houver melhora ou bons padr√µes
            4. Tend√™ncia semanal do sono (melhorando, piorando ou est√°vel)
            
            ### Dados de Sono:
            $jsonData
            
            ### Dados de Sonecas (se houver):
            $napData
            
            Responda em formato JSON com as seguintes chaves:
            {
                "tips": ["dica1", "dica2", ...],
                "warnings": ["aviso1", "aviso2", ...],
                "positiveReinforcement": "mensagem de refor√ßo positivo ou null",
                "weeklyTrend": "descri√ß√£o da tend√™ncia semanal"
            }
            
            Seja espec√≠fico e pr√°tico nas dicas. Evite recomenda√ß√µes gen√©ricas.
            Baseie suas recomenda√ß√µes em padr√µes reais detectados nos dados.
            Considere fatores como:
            - Distribui√ß√£o dos est√°gios do sono (ideal: Profundo > 20%, REM > 20%, Leve ~55%)
            - Frequ√™ncia card√≠aca durante o sono
            - Satura√ß√£o de oxig√™nio
            - Ronco e apneia
            - Movimentos noturnos
            - Hor√°rios de deitar e acordar
            - Sonecas durante o dia
        """.trimIndent()
    }
    
    /**
     * Constr√≥i um prompt avan√ßado para an√°lise di√°ria de sono
     */
    private fun buildAdvancedDailyPrompt(sleepData: SleepDataDto, sleepStages: SleepStagesDetail, healthMetrics: HealthMetrics): String {
        val jsonData = gson.toJson(sleepData)
        val stagesData = gson.toJson(sleepStages)
        val metricsData = gson.toJson(healthMetrics)
        
        return """
            ## üí≠ Prompt Avan√ßado para An√°lise Di√°ria do Sono com IA
            
            Analise os seguintes dados de uma noite de sono:
            
            ### Dados B√°sicos:
            $jsonData
            
            ### Est√°gios do Sono:
            $stagesData
            
            ### M√©tricas de Sa√∫de:
            $metricsData
            
            Forne√ßa:
            1. Uma an√°lise curta e espec√≠fica desta noite de sono
            2. 1-2 recomenda√ß√µes pr√°ticas baseadas exclusivamente nesta noite
            
            Considere:
            - Efici√™ncia do sono (ideal > 85%)
            - Distribui√ß√£o dos est√°gios do sono (ideal: Profundo > 20%, REM > 20%, Leve ~55%)
            - N√∫mero de despertares durante a noite
            - Dura√ß√£o total do sono (ideal: 7-9 horas)
            - Frequ√™ncia card√≠aca durante o sono
            - Presen√ßa de ronco ou apneia
            - Movimentos durante o sono
            - Hor√°rio de dormir e acordar
            
            Responda em formato JSON com as seguintes chaves:
            {
                "analysis": "An√°lise curta e espec√≠fica desta noite",
                "recommendations": ["recomenda√ß√£o1", "recomenda√ß√£o2"]
            }
            
    }
    
    /**
     * Simula dados de satura√ß√£o de oxig√™nio durante o sono
     */
    private fun simulateOxygenData(session: SleepSession): Int {
        // Satura√ß√£o de oxig√™nio normal: 95-100%
        val baseOxygen = 97
        
        // Ajustes baseados na efici√™ncia e est√°gios do sono
        val efficiencyFactor = (session.efficiency - 80) / 20
        val deepSleepFactor = (session.deepSleepPercentage - 20) / 10
        
        // Valor final
        return (baseOxygen + efficiencyFactor + deepSleepFactor).toInt().coerceIn(92, 99)
    }
    
    /**
     * Classe auxiliar para dados de frequ√™ncia card√≠aca
     */
    data class HeartRateData(val average: Int, val min: Int, val max: Int)
    
    /**
     * Classe auxiliar para dados de ronco
     */
    data class SnoringData(val detected: Boolean, val duration: Int)
    
    /**
     * Simula dados de frequ√™ncia card√≠aca durante o sono
     */
    private fun simulateHeartRateData(session: SleepSession): HeartRateData {
        // Em uma implementa√ß√£o real, esses dados viriam do Health Connect
        // Aqui estamos simulando valores realistas baseados na dura√ß√£o e qualidade do sono
        
        // Frequ√™ncia card√≠aca m√©dia durante o sono: tipicamente entre 50-70 bpm
        val baseAverage = 60
        
        // Ajustes baseados na efici√™ncia do sono
        val efficiencyFactor = (session.efficiency - 75) / 10
        
        // Valores finais
        val average = (baseAverage - efficiencyFactor).toInt().coerceIn(50, 80)
        val min = (average - 10 - (Math.random() * 5).toInt()).coerceIn(40, 60)
        val max = (average + 15 + (Math.random() * 10).toInt()).coerceIn(70, 100)
        
        return HeartRateData(average, min, max)
    }
    
    /**
     * Simula dados de ronco durante o sono
     */
    private fun simulateSnoringData(session: SleepSession): SnoringData {
        // Probabilidade base de ronco: 30%
        val snoreProbability = 0.3
        
        // Fatores que aumentam a probabilidade de ronco
        val deepSleepFactor = if (session.deepSleepPercentage < 15) 0.2 else 0.0
        val efficiencyFactor = if (session.efficiency < 75) 0.2 else 0.0
        
        // Probabilidade final
        val finalProbability = snoreProbability + deepSleepFactor + efficiencyFactor
        
        // Determina se houve ronco
        val detected = Math.random() < finalProbability
        
        // Se houve ronco, calcula a dura√ß√£o
        val duration = if (detected) {
            val totalMinutes = session.duration.toMinutes()
            (totalMinutes * (0.1 + Math.random() * 0.2)).toInt() // 10-30% do tempo total
        } else 0
        
        return SnoringData(detected, duration)
    }
    
    /**
     * Simula dados de movimento durante o sono
     */
    private fun simulateMovementData(session: SleepSession): Int {
        // Movimentos base durante o sono: 10-30 por noite
        val baseMovements = 20
        
        // Fatores que afetam o n√∫mero de movimentos
        val durationFactor = (session.duration.toHours() - 7) * 2
        val efficiencyFactor = (80 - session.efficiency) / 5
        val remFactor = (session.remSleepPercentage - 20) * (-0.5)
        
        // Valor final com alguma aleatoriedade
        return (baseMovements + durationFactor + efficiencyFactor + remFactor + (Math.random() * 10 - 5)).toInt().coerceIn(5, 50)
    }
    
    /**
     * Cria detalhes dos est√°gios de sono a partir de uma sess√£o
     */
    private fun createSleepStagesDetail(session: SleepSession): SleepStagesDetail {
        val totalMinutes = session.duration.toMinutes().toDouble()
        
        // Se h√° est√°gios reais, use-os
        if (session.stages.isNotEmpty()) {
            val lightMinutes = session.stages.filter { it.type == SleepStageType.LIGHT }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
                
            val deepMinutes = session.stages.filter { it.type == SleepStageType.DEEP }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
                
            val remMinutes = session.stages.filter { it.type == SleepStageType.REM }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
                
            val awakeMinutes = session.stages.filter { it.type == SleepStageType.AWAKE }
                .fold(Duration.ZERO) { acc, stage -> acc.plus(stage.duration) }
                .toMinutes()
            
            // Calcular porcentagens
            val lightPercentage = if (totalMinutes > 0) (lightMinutes.toDouble() / totalMinutes) * 100 else 0.0
            val deepPercentage = if (totalMinutes > 0) (deepMinutes.toDouble() / totalMinutes) * 100 else 0.0
            val remPercentage = if (totalMinutes > 0) (remMinutes.toDouble() / totalMinutes) * 100 else 0.0
            val awakePercentage = if (totalMinutes > 0) (awakeMinutes.toDouble() / totalMinutes) * 100 else 0.0
            
            return SleepStagesDetail(
                light = formatDuration(Duration.ofMinutes(lightMinutes)),
                deep = formatDuration(Duration.ofMinutes(deepMinutes)),
                rem = formatDuration(Duration.ofMinutes(remMinutes)),
                awake = formatDuration(Duration.ofMinutes(awakeMinutes)),
                lightPercentage = lightPercentage,
                deepPercentage = deepPercentage,
                remPercentage = remPercentage,
                awakePercentage = awakePercentage,
                isEstimated = false
            )
        } else {
            // Simular est√°gios baseados em distribui√ß√µes t√≠picas
            // Distribui√ß√£o t√≠pica: 55% sono leve, 20% sono profundo, 20% REM, 5% acordado
            val lightMinutes = (totalMinutes * 0.55).toLong()
            val deepMinutes = (totalMinutes * 0.20).toLong()
            val remMinutes = (totalMinutes * 0.20).toLong()
            val awakeMinutes = totalMinutes.toLong() - lightMinutes - deepMinutes - remMinutes
            
            return SleepStagesDetail(
                light = formatDuration(Duration.ofMinutes(lightMinutes)),
                deep = formatDuration(Duration.ofMinutes(deepMinutes)),
                rem = formatDuration(Duration.ofMinutes(remMinutes)),
                awake = formatDuration(Duration.ofMinutes(awakeMinutes)),
                lightPercentage = 55.0,
                deepPercentage = 20.0,
                remPercentage = 20.0,
                awakePercentage = 5.0,
                isEstimated = true
            )
        }
    }
    
    /**
     * Formata uma dura√ß√£o em formato leg√≠vel
     */
    private fun formatDuration(duration: Duration): String {
        val hours = duration.toHours()
        val minutes = duration.toMinutesPart()
        return if (hours > 0) {
            "${hours}h${minutes}min"
        } else {
            "${minutes}min"
        }
    }
    
    /**
     * Detecta sonecas (naps) a partir das sess√µes de sono
     */
    private fun detectNaps(sessions: List<SleepSession>): List<NapData> {
        val naps = mutableListOf<NapData>()
        
        // Considera como soneca qualquer sess√£o de sono com menos de 3 horas de dura√ß√£o
        // que ocorre entre 9h e 18h
        for (session in sessions) {
            val hour = session.startTime.hour
            val duration = session.duration
            
            if (hour in 9..18 && duration.toHours() < 3) {
                // Qualidade da soneca baseada na dura√ß√£o (ideal: 20-30 minutos ou 90 minutos)
                val durationMinutes = duration.toMinutes()
                val quality = when {
                    durationMinutes in 15..30 -> "Boa"
                    durationMinutes in 85..95 -> "Excelente"
                    durationMinutes > 30 && durationMinutes < 85 -> "Regular"
                    durationMinutes > 95 -> "Longa demais"
                    else -> "Curta demais"
                }
                
                // Determina se a soneca foi restauradora
                val isRestorative = quality in listOf("Boa", "Excelente")
                
                naps.add(NapData(
                    startTime = session.startTime.format(timeFormatter),
                    endTime = session.endTime.format(timeFormatter),
                    duration = formatDuration(duration),
                    quality = quality,
                    isRestorative = isRestorative
                ))
            }
        }
        
        return naps
    }
    
    /**
     * Encontra sonecas para um dia espec√≠fico
     */
    private fun findNapsForDay(naps: List<NapData>, date: ZonedDateTime): List<NapData> {
        // Em uma implementa√ß√£o real, filtrar√≠amos por data
        // Aqui estamos retornando todas as sonecas para simplificar
        return naps
    }
    
    /**
     * Calcula a pontua√ß√£o de qualidade do sono (0-100)
     */
    private fun calculateSleepScore(session: SleepSession, healthMetrics: HealthMetrics): Int {
        // Base: efici√™ncia do sono j√° calculada (0-100)
        var score = session.efficiency
        
        // Ajustes baseados em m√©tricas de sa√∫de
        
        // Frequ√™ncia card√≠aca: ideal √© ter uma boa varia√ß√£o entre m√≠nima e m√°xima
        val heartRateVariation = (healthMetrics.maxHeartRate ?: 0) - (healthMetrics.minHeartRate ?: 0)
        if (heartRateVariation > 20) score += 5 else if (heartRateVariation < 10) score -= 5
        
        // Satura√ß√£o de oxig√™nio: ideal > 95%
        val oxygen = healthMetrics.oxygenSaturation ?: 0
        when {
            oxygen >= 97 -> score += 5
            oxygen >= 95 -> score += 2
            oxygen < 93 -> score -= 10
        }
        
        // Ronco: penalidade se detectado
        if (healthMetrics.snoringDetected == true) score -= 5
        
        // Movimentos: ideal √© ter poucos movimentos
        val movements = healthMetrics.movementCount ?: 0
        when {
            movements < 15 -> score += 3
            movements > 30 -> score -= 3
        }
        
        return score.toInt().coerceIn(0, 100)
    }
    
    /**
     * Obt√©m a classifica√ß√£o verbal da qualidade do sono
     */
    private fun getSleepQualityLabel(score: Int): String {
        return when {
            score >= 90 -> "Excelente"
            score >= 80 -> "Muito Boa"
            score >= 70 -> "Boa"
            score >= 60 -> "Regular"
            score >= 50 -> "Razo√°vel"
            score >= 40 -> "Insatisfat√≥ria"
            else -> "Ruim"
        }
    }
    
    /**
     * Gera um fato cient√≠fico personalizado baseado nos dados de sono
     */
    private fun generateScientificFact(session: SleepSession, sleepStages: SleepStagesDetail): String {
        // Lista de fatos cient√≠ficos sobre o sono
        val facts = listOf(
            "O sono REM est√° ligado √† regula√ß√£o emocional e ao processamento de mem√≥rias.",
            "Durante o sono profundo, o c√©rebro consolida mem√≥rias e o corpo libera horm√¥nio do crescimento.",
            "Um ciclo completo de sono dura cerca de 90 minutos, passando por est√°gios leve, profundo e REM.",
            "A melatonina, horm√¥nio que regula o sono, √© suprimida pela luz azul de telas.",
            "Adultos precisam em m√©dia de 7-9 horas de sono por noite para fun√ß√µes cognitivas √≥timas.",
            "O sono profundo √© essencial para a recupera√ß√£o f√≠sica do corpo.",
            "A temperatura ideal do quarto para dormir √© entre 18-20¬∞C.",
            "Durante o sono REM, o corpo fica temporariamente paral√≠sado para evitar que atuemos nossos sonhos."
        )
        
        // Seleciona um fato baseado nos dados de sono
        return when {
            sleepStages.remPercentage > 25 -> 
                "Voc√™ teve ${sleepStages.rem} de sono REM (${sleepStages.remPercentage.toInt()}%), acima da m√©dia. O sono REM √© essencial para a consolida√ß√£o da mem√≥ria e criatividade."
            
            sleepStages.deepPercentage > 25 -> 
                "Voc√™ teve ${sleepStages.deep} de sono profundo (${sleepStages.deepPercentage.toInt()}%), acima da m√©dia. O sono profundo √© quando ocorre a maior parte da recupera√ß√£o f√≠sica."
            
            sleepStages.deepPercentage < 15 -> 
                "Voc√™ teve apenas ${sleepStages.deep} de sono profundo (${sleepStages.deepPercentage.toInt()}%). O sono profundo √© essencial para a recupera√ß√£o f√≠sica e imunidade."
            
            sleepStages.remPercentage < 15 -> 
                "Voc√™ teve apenas ${sleepStages.rem} de sono REM (${sleepStages.remPercentage.toInt()}%). O sono REM √© importante para a sa√∫de mental e processamento emocional."
            
            session.duration.toHours() > 9 -> 
                "Voc√™ dormiu mais de 9 horas. Embora o sono seja importante, dormir demais regularmente pode estar associado a problemas de sa√∫de."
            
            session.duration.toHours() < 6 -> 
                "Voc√™ dormiu menos de 6 horas. A priva√ß√£o cr√¥nica de sono pode afetar negativamente a mem√≥ria, humor e imunidade."
            
            else -> facts.random()
        }
    }
    
    /**
     * Gera um fato cient√≠fico semanal baseado nos dados de sono
     */
    private fun generateWeeklyScientificFact(sessions: List<SleepSession>, dailyAnalyses: List<DailyAnalysis>): String {
        // Calcula a m√©dia de horas dormidas
        val avgHours = sessions.map { it.duration.toHours() }.average()
        
        // Calcula a m√©dia de cada est√°gio do sono
        val avgDeepPercentage = sessions.map { it.deepSleepPercentage }.average()
        val avgRemPercentage = sessions.map { it.remSleepPercentage }.average()
        
        return when {
            avgHours < 6.5 -> 
                "Na √∫ltima semana, voc√™ dormiu em m√©dia ${String.format("%.1f", avgHours)} horas por noite. Estudos mostram que dormir menos de 7 horas regularmente aumenta o risco de problemas de sa√∫de."
            
            avgDeepPercentage < 15 -> 
                "Sua m√©dia de sono profundo foi de ${String.format("%.1f", avgDeepPercentage)}%, abaixo do ideal. O sono profundo √© essencial para a recupera√ß√£o f√≠sica e imunidade."
            
            avgRemPercentage < 15 -> 
                "Sua m√©dia de sono REM foi de ${String.format("%.1f", avgRemPercentage)}%, abaixo do ideal. O sono REM √© crucial para a sa√∫de mental, aprendizado e mem√≥ria."
            
            avgHours >= 7 && avgHours <= 9 && avgDeepPercentage >= 20 && avgRemPercentage >= 20 -> 
                "Parab√©ns! Seus padr√µes de sono est√£o pr√≥ximos do ideal, com boa dura√ß√£o e distribui√ß√£o de est√°gios. Isso contribui para melhor sa√∫de f√≠sica e mental."
            
            else -> 
                "Sabia que o sono segue ciclos de aproximadamente 90 minutos? Um adulto t√≠pico passa por 4-6 ciclos por noite, cada um com est√°gios de sono leve, profundo e REM."
        }
    }
    
    /**
     * Detecta a tend√™ncia de sono ao longo da semana
     */
    private fun detectSleepTrend(sessions: List<SleepSession>): String {
        if (sessions.size < 3) return "Dados insuficientes para detectar tend√™ncia"
        
        // Ordena sess√µes por data
        val sortedSessions = sessions.sortedBy { it.startTime }
        
        // Analisa tend√™ncia de efici√™ncia
        val firstHalf = sortedSessions.take(sortedSessions.size / 2)
        val secondHalf = sortedSessions.drop(sortedSessions.size / 2)
        
        val firstHalfEfficiency = firstHalf.map { it.efficiency }.average()
        val secondHalfEfficiency = secondHalf.map { it.efficiency }.average()
        
        val efficiencyDiff = secondHalfEfficiency - firstHalfEfficiency
        
        return when {
            efficiencyDiff > 5 -> "Sua qualidade de sono est√° melhorando ao longo da semana"
            efficiencyDiff < -5 -> "Sua qualidade de sono est√° piorando ao longo da semana"
            else -> "Sua qualidade de sono est√° est√°vel ao longo da semana"
        }
    }
    
    /**
     * Gera recomenda√ß√£o de hor√°rio ideal para sonecas
     */
    private fun generateRecommendedNapTime(sessions: List<SleepSession>): String {
        // Analisa hor√°rios de dormir e acordar para recomendar melhor hor√°rio para soneca
        val avgWakeupTime = sessions.map { it.endTime.hour + it.endTime.minute / 60.0 }.average()
        
        // Recomenda soneca entre 6-8 horas ap√≥s acordar, ou entre 13h-15h
        val recommendedHour = if (avgWakeupTime > 0) {
            val napTime = (avgWakeupTime + 7).coerceIn(13.0, 15.0)
            napTime
        } else {
            14.0 // Hor√°rio padr√£o se n√£o houver dados suficientes
        }
        
        val hour = recommendedHour.toInt()
        val minute = ((recommendedHour - hour) * 60).toInt()
        
        return String.format("%02d:%02d", hour, minute)
    }
    
    private fun parseAIResponse(response: String): SleepAdvice {
        return try {
            val weeklyAdvice = gson.fromJson(response, WeeklyAdvice::class.java)
            SleepAdvice(
                tips = weeklyAdvice.tips,
                warnings = weeklyAdvice.warnings,
                positiveReinforcement = weeklyAdvice.positiveReinforcement,
                dailyAnalysis = emptyList() // Ser√° preenchido separadamente
            )
        } catch (e: Exception) {
            SleepAdvice(
                tips = listOf("Erro ao processar a resposta da IA."),
                warnings = emptyList(),
                positiveReinforcement = null,
                dailyAnalysis = emptyList()
            )
        }
    }
}

/**
 * DTO com dados detalhados de sono para an√°lise pela IA
 */
data class SleepDataDto(
    @SerializedName("date") val date: String,
    @SerializedName("totalSleep") val totalSleep: String,
    @SerializedName("deepSleepPercentage") val deepSleepPercentage: Double,
    @SerializedName("remSleepPercentage") val remSleepPercentage: Double,
    @SerializedName("lightSleepPercentage") val lightSleepPercentage: Double,
    @SerializedName("wakeCount") val wakeCount: Int,
    @SerializedName("efficiency") val efficiency: Double,
    @SerializedName("heartRateAvg") val heartRateAvg: Int? = null,
    @SerializedName("heartRateMin") val heartRateMin: Int? = null,
    @SerializedName("heartRateMax") val heartRateMax: Int? = null,
    @SerializedName("oxygenSaturation") val oxygenSaturation: Int? = null,
    @SerializedName("snoring") val snoring: Boolean? = null,
    @SerializedName("snoringDuration") val snoringDuration: Int? = null,
    @SerializedName("movementCount") val movementCount: Int? = null,
    @SerializedName("bedtime") val bedtime: String? = null,
    @SerializedName("wakeupTime") val wakeupTime: String? = null,
    @SerializedName("isDataEstimated") val isDataEstimated: Boolean = false
)

/**
 * Resposta da an√°lise semanal de sono
 */
data class WeeklyAdvice(
    val tips: List<String>,
    val warnings: List<String>,
    val positiveReinforcement: String?,
    val weeklyTrend: String? = null,
    val sleepScore: Int? = null,
    val sleepQuality: String? = null
)

/**
 * An√°lise detalhada de uma noite de sono
 */
data class DailyAnalysis(
    val date: String,
    val analysis: String,
    val recommendations: List<String>,
    val sleepScore: Int? = null,
    val sleepQuality: String? = null,
    val sleepStages: SleepStagesDetail? = null,
    val scientificFact: String? = null,
    val healthMetrics: HealthMetrics? = null,
    val naps: List<NapData>? = null
)

/**
 * Detalhes sobre os est√°gios do sono
 */
data class SleepStagesDetail(
    val light: String,
    val deep: String,
    val rem: String,
    val awake: String,
    val lightPercentage: Double,
    val deepPercentage: Double,
    val remPercentage: Double,
    val awakePercentage: Double,
    val isEstimated: Boolean = false
)

/**
 * M√©tricas de sa√∫de durante o sono
 */
data class HealthMetrics(
    val averageHeartRate: Int? = null,
    val minHeartRate: Int? = null,
    val maxHeartRate: Int? = null,
    val oxygenSaturation: Int? = null,
    val snoringDetected: Boolean? = null,
    val snoringDuration: String? = null,
    val movementCount: Int? = null
)

/**
 * Dados sobre sonecas (naps)
 */
data class NapData(
    val startTime: String,
    val endTime: String,
    val duration: String,
    val quality: String,
    val isRestorative: Boolean
)

/**
 * Resposta completa da an√°lise de sono com dicas e an√°lises di√°rias
 */
data class SleepAdvice(
    val tips: List<String>,
    val warnings: List<String>,
    val positiveReinforcement: String?,
    val dailyAnalysis: List<DailyAnalysis>,
    val weeklyScore: Int? = null,
    val weeklyQuality: String? = null,
    val weeklyTrend: String? = null,
    val scientificFact: String? = null,
    val recommendedNapTime: String? = null
)